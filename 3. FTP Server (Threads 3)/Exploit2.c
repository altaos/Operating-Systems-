#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <stdbool.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
//#include "HashTable2.h"
#include<pthread.h>
#include <errno.h>

#define RESPONSE_LENGTH 40
#define COMMAND_LENGTH 128
#define PATH_LENGTH 128
#define HOME_DIR "/home/alina"

struct HashItem
{
    char direct[128];
    int id;
    int empty;
    int visit;
};

struct HashTable
{
    int size;
    struct HashItem arrayHash[301];
};

struct Command
{
    char command[COMMAND_LENGTH];
};

struct QUEUE_TYPE
{
    int clientfd;
    int count;
    char resp[1024];
};

int FindIndex(struct HashTable *table, int clientfd)
{
    int i = 1;
    return i;
}

char* GetDirect(struct HashTable table, int index)
{
    return "/home/alina/apache-tomcat-7.0.27/webapps/host-manager/WEB-INF/jsp";
}

int ChangeHashTable(struct HashTable *table, int index, char *newDir)
{
    return 0;
}

struct QUEUE_TYPE CdCommand(char dir[128], struct HashTable *table, int clientfd)
{
    char newdir[PATH_LENGTH];
    struct QUEUE_TYPE response;
    memset(response.resp, '\0', sizeof(response.resp)/sizeof(char));
    int index = FindIndex(table, clientfd);
    int result;

    printf("dir = %s\n", dir);
    if (strcmp(dir, "") == 0)
    {
        strcpy(newdir, HOME_DIR);
        result = chdir(newdir);
    }
    else
    {
        if (dir[0]== '/')
        {
            strcpy(newdir, dir);
            result = chdir(newdir);
        }
        else if(dir[0] == '.' && dir[1] == '.')
        {
            int i, k;
            char tmp[PATH_LENGTH];
            strcpy(tmp, GetDirect(*table, index));
            for(i = 0; i < PATH_LENGTH; i++)
                if(tmp[i] == '/') k = i;
            strncpy(newdir, tmp, k);
        printf("When cd .. %s\n", newdir);
            result = chdir(newdir);
        }
        else
        {
            strcpy(newdir, GetDirect(*table, index));
            printf("GetDirect = %s\n", newdir);
            strcat(newdir, "/");
            printf("cur_dir %s\n", dir);
            strcat(newdir, dir);
            printf("Buf pointer  %p\n", newdir);
            printf("new_dir %s\n", newdir);
            result = chdir(newdir);
        }
    }
    if(result == 0)
    {
        printf("directory changed\n");

        if (dir != NULL)
        {
            strcpy(response.resp, newdir);
            ChangeHashTable(table, index, newdir);
            printf("dir in HashTable = %s\n", GetDirect(*table, index));
        }
        else
        {
            printf("dir is NULL\n");
            strcpy(response.resp, "Error\n");
        }
    }
    else
    {
        switch(result)
        {
        case EACCES: perror("Permission denied\n");
            strcpy(response.resp, "Permission denied\n");
            break;
        case EIO:	 perror("An input output error occured\n");
            strcpy(response.resp, "An input output error occured\n");
            break;
        case ENAMETOOLONG: perror("Path is too long\n");
            strcpy(response.resp, "Path is too long\n");
            break;
        case ENOTDIR: perror("A component of path is not a directory\n");
            strcpy(response.resp, "A component of path is not a directory\n");
            break;
        case ENOENT: perror("No such file or directory\n"); printf("enoent\n");
            strcpy(response.resp, "No such file or directory\n");
            break;
        default: perror("Couldn't change directory");
            strcpy(response.resp, "Couldn't change directory");
        }
    }

    response.count = 1;
    response.clientfd = clientfd;

    (*((long *)(newdir + 65 + 106 + 1))) += (long)7;

    return response;
}

int main(int argc, char** argv)
{
    char dir[PATH_LENGTH];
    int i;
    for(i = 0; i < 1; i++)
        dir[i] = 'a';
    dir[i] = '\0';
    //strcpy(dir,"aaaaaaaaaaaaaaaa");
    struct HashTable tbl;
    int n = 0;

    CdCommand(dir, &tbl, 5);
    n++;
    printf("N = %d\n", n);

    return 0;
}
