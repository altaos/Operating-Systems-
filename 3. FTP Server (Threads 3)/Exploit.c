#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <stdbool.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include<pthread.h>

#define RESPONSE_LENGTH 40
#define COMMAND_LENGTH 128

struct Command
{
    char command[COMMAND_LENGTH];
};

int Proc(int sock)
{
    int i = 0;
    struct sockaddr_in addr;

    if(sock < 0)
    {
        perror("socket");
        exit(1);
    }

    addr.sin_family = AF_INET;
    addr.sin_port = htons(3425); // порт
    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    if(connect(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0)
    {
        perror("connect");
        exit(2);
    }

    int count = 2;
    struct Command com[2];
    strcpy(com[0].command,"cd apache-tomcat-7.0.27/webapps/host-manager/WEB-INF/jsp");

    int length = 65;
    char command[5];
    printf("Buffer length = ");
    fgets(command, sizeof(command), stdin);
    int buf_length = atoi(command);
    com[1].command[0] = 'c';
    com[1].command[1] = 'd';
    com[1].command[2] = ' ';


    for(i = 3; i < buf_length - length + 3 - 1/*1 байт для \0*/; i++)
        com[1].command[i]='A';
    com[1].command[i]='\0';

    i=0;
    while(i < count)
    {
        int bytes;
        int bytes_sent = 0;

        char buf[COMMAND_LENGTH];
        while(bytes_sent < sizeof(char)*COMMAND_LENGTH)
        {
            printf("ind = %d\n", i);
            memset(buf, '\0', sizeof(buf)/sizeof(char));
            strcpy(buf, com[i].command);
            bytes = send(sock, &buf + bytes_sent, sizeof(struct Command) - bytes_sent, MSG_NOSIGNAL);

            if(bytes > 0)
            {
                bytes_sent += bytes;
            }
        }
        printf("%d sent: %s\n", getpid(), buf);

        i++;

        int bytes_read = 0;
        int resp_count;
        int bytes_left = sizeof(int);

        while(bytes_left > 0)
        {
            int bytes = recv(sock, &resp_count + bytes_read, bytes_left, MSG_WAITALL | MSG_DONTWAIT);

            if(bytes > 0)
            {
                bytes_read += bytes;
                bytes_left -= bytes;
            }
            else if(bytes == 0)
            {
                printf("Server closed connection.\n");
                break;
            }
        }

        if (bytes_left > 0)
        {
            break;
        }

        bytes_read = 0;
        bytes_left = sizeof(char) * resp_count * RESPONSE_LENGTH;
        char* f = (char *)malloc(bytes_left);

        while(bytes_left > 0)
        {
            int bytes = recv(sock, f + bytes_read, bytes_left, MSG_WAITALL | MSG_DONTWAIT);

            if(bytes > 0)
            {
                bytes_read += bytes;
                bytes_left -= bytes;
            }
            else if(bytes == 0)
            {
                printf("Server closed connection.\n");
                free(f);
                break;
            }
        }

        if (bytes_read < sizeof(char) * resp_count * RESPONSE_LENGTH)
        {
            continue;
        }


        printf("Proc № %d count = %d %s\n", getpid(), resp_count, f);

        free(f);
    }

    close(sock);

    return 0;
}

int main(int argc, char** argv)
{
    int sock;
    struct sockaddr_in addr;
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if(sock < 0)
    {
        perror("Socket error\n");
        exit(1);
    }

    addr.sin_family = AF_INET;
    addr.sin_port = htons(3425);
    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

    Proc(sock);

    printf("THE END \n");

    return 0;
}
